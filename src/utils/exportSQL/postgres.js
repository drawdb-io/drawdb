import { escapeQuotes, exportFieldComment, parseDefault } from "./shared";

import { dbToTypes } from "../../data/datatypes";

export function toPostgres(diagram) {
  const enumStatements = diagram.enums
    .map(
      (e) =>
        `CREATE TYPE "${e.name}" AS ENUM (\n${e.values.map((v) => `\t'${v}'`).join(",\n")}\n);\n`,
    )
    .join("\n");

  const typeStatements = diagram.types
    .map(
      (type) =>
        `CREATE TYPE ${type.name} AS (\n${type.fields
          .map((f) => `\t${f.name} ${f.type}`)
          .join(",\n")}\n);\n\n${
          type.comment && type.comment.trim() !== ""
            ? `\nCOMMENT ON TYPE "${type.name}" IS '${escapeQuotes(type.comment)}';\n\n`
            : ""
        }`,
    )
    .join("\n");

  return `${enumStatements}${enumStatements.trim() !== "" ? `\n${typeStatements}` : typeStatements}${diagram.tables
    .map(
      (table) =>
        `CREATE TABLE "${table.name}" (\n${table.fields
          .map(
            (field) =>
              `${exportFieldComment(field.comment)}\t"${
                field.name
              }" ${field.type}${
                field.size !== undefined && field.size !== ""
                  ? "(" + field.size + ")"
                  : ""
              }${field.isArray ? " ARRAY" : ""}${field.notNull ? " NOT NULL" : ""}${field.unique ? " UNIQUE" : ""}${
                field.increment ? " GENERATED BY DEFAULT AS IDENTITY" : ""
              }${
                field.default.trim() !== ""
                  ? ` DEFAULT ${parseDefault(field, diagram.database)}`
                  : ""
              }${
                field.check === "" ||
                !dbToTypes[diagram.database][field.type].hasCheck
                  ? ""
                  : ` CHECK(${field.check})`
              }`,
          )
          .join(",\n")}${
          table.fields.filter((f) => f.primary).length > 0
            ? `,\n\tPRIMARY KEY(${table.fields
                .filter((f) => f.primary)
                .map((f) => `"${f.name}"`)
                .join(", ")})`
            : ""
        }\n);${
          table.comment.trim() !== ""
            ? `\nCOMMENT ON TABLE "${table.name}" IS '${escapeQuotes(table.comment)}';\n`
            : ""
        }${table.fields
          .map((field) =>
            field.comment.trim() !== ""
              ? `COMMENT ON COLUMN ${table.name}.${field.name} IS '${escapeQuotes(field.comment)}';\n`
              : "",
          )
          .join("")}${table.indices
          .map(
            (i) =>
              `\nCREATE ${i.unique ? "UNIQUE " : ""}INDEX "${
                i.name
              }"\nON "${table.name}" (${i.fields
                .map((f) => `"${f}"`)
                .join(", ")});`,
          )
          .join("\n")}\n`,
    )
    .join("\n")}${diagram.references
    .map((r) => {
      const { name: startName, fields: startFields } = diagram.tables.find(
        (t) => t.id === r.startTableId,
      );

      const { name: endName, fields: endFields } = diagram.tables.find(
        (t) => t.id === r.endTableId,
      );

      return `\nALTER TABLE "${startName}"\nADD FOREIGN KEY("${
        startFields.find((f) => f.id === r.startFieldId)?.name
      }") REFERENCES "${endName}"("${
        endFields.find((f) => f.id === r.endFieldId)?.name
      }")\nON UPDATE ${r.updateConstraint.toUpperCase()} ON DELETE ${r.deleteConstraint.toUpperCase()};`;
    })
    .join("\n")}`;
}
